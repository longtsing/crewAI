---
title: 工具
description: 为 CrewAI 代理提供额外功能的扩展组件。
icon: toolbox
mode: "wide"
---

## 概述

工具是 CrewAI 代理的核心组件，使它们能够与外部系统交互、访问数据源和执行超出其原生语言模型能力的操作。

## 工具架构

CrewAI 的工具系统基于以下架构：

### 1. 基础工具接口
所有工具都继承自 `BaseTool`，提供一致的方法和属性：

```python
from crewai.tools import BaseTool
from typing import Type, Optional
from pydantic import BaseModel

class CustomTool(BaseTool):
    name: str = "自定义工具名称"
    description: str = "工具功能的详细描述"
    args_schema: Optional[Type[BaseModel]] = None  # 输入参数架构
    
    def _run(self, **kwargs):
        # 工具逻辑实现
        return {"result": "工具执行结果"}
```

### 2. 工具装饰器
使用 `@tool` 装饰器简化工具创建：

```python
from crewai.tools import tool

@tool
def web_search(query: str) -> dict:
    """执行网络搜索并返回结果。"""
    # 搜索逻辑
    return {"results": f"搜索 '{query}' 的结果"}

@tool
def file_processor(file_path: str, operation: str) -> dict:
    """处理文件的读取、写入或删除操作。"""
    # 文件处理逻辑
    return {"status": f"对 {file_path} 执行了 {operation} 操作"}
```

### 3. 内置工具类型

CrewAI 提供多种内置工具类型：

#### 搜索工具
- **搜索工具**：执行网络搜索和数据库查询
- **API 工具**：与外部服务集成
- **知识检索工具**：访问知识库和向量存储

#### 数据处理工具
- **文件操作工具**：读取、写入、复制文件
- **数据转换工具**：格式转换、数据清洗、验证

#### 通信工具
- **邮件工具**：发送邮件和通知
- **API 工具**：REST API 调用和 Webhook

#### 开发工具
- **Git 工具**：版本控制操作
- **测试工具**：单元测试和集成测试
- **部署工具**：CI/CD 集成

## 内置工具详解

### 1. Serper Dev 工具
```python
from crewai.tools import SerperDevTool

search_tool = SerperDevTool()
```

功能：实时网络搜索，提供最新的搜索结果。

### 2. 文件操作工具
```python
from crewai.tools import FileReadTool, FileWriteTool, DirectoryReadTool

# 读取文件
reader = FileReadTool()
result = reader._run(file_path="data.txt")

# 写入文件
writer = FileWriteTool()
result = writer._run(file_path="output.txt", content="数据内容")

# 读取目录
dir_reader = DirectoryReadTool()
result = dir_reader._run(directory_path="./data")
```

### 3. ScrapeWebsiteTool
```python
from crewai.tools import ScrapeWebsiteTool

scraper = ScrapeWebsiteTool()
result = scraper._run(url="https://example.com")
```

功能：从网站提取内容和数据。

### 4. PDF 处理工具
```python
from crewai.tools import PDFReadTool

pdf_reader = PDFReadTool()
result = pdf_reader._run(file_path="document.pdf")
```

功能：从 PDF 文档中提取文本和元数据。

## 自定义工具开发

### 创建自定义工具
```python
from crewai.tools import BaseTool
from pydantic import BaseModel
from typing import Optional

class WeatherTool(BaseTool):
    name: "天气查询"
    description: "获取指定位置的当前天气信息"
    
    class WeatherInput(BaseModel):
        location: str
        units: Optional[str] = "metric"  # metric, imperial, or kelvin
    
    args_schema = WeatherInput
    
    def _run(self, location: str, units: str = "metric"):
        # 实现天气查询逻辑
        # 这里可以调用天气 API
        return {
            "location": location,
            "temperature": "25°C",
            "conditions": "晴天",
            "units": units
        }
```

### 错误处理和验证
```python
from crewai.tools import BaseTool
from typing import Any

class RobustTool(BaseTool):
    def _run(self, **kwargs):
        try:
            # 工具主要逻辑
            result = self.perform_operation(**kwargs)
            return result
        except Exception as e:
            return {
                "error": str(e),
                "error_type": type(e).__name__,
                "suggestion": "请检查输入参数并重试"
            }
    
    def perform_operation(self, **kwargs):
        # 具体的工具实现
        pass
```

### 工具配置和安全

#### 环境变量配置
```python
import os
from crewai import Agent, Crew

# 配置工具的环境变量
os.environ["WEATHER_API_KEY"] = "your-api-key"
os.environ["DATABASE_URL"] = "your-database-url"

agent = Agent(
    role="数据分析师",
    tools=[weather_tool],
    llm=LLM(model="gpt-4")
)
```

#### 工具权限控制
```python
# 在代理级别控制工具访问
agent = Agent(
    role="受限代理",
    tools=[safe_tools],  # 仅允许安全工具
    dangerous_tools_enabled=False  # 禁用危险工具
)

# 或在任务级别控制
task = Task(
    description="执行数据处理任务",
    agent=agent,
    tools=[data_processing_tools]  # 为此任务允许特定工具
)
```

## 高级工具特性

### 1. 工具缓存
```python
from crewai.tools import BaseTool
import time
from functools import lru_cache

class CachedAPIHelper(BaseTool):
    def __init__(self):
        self._cache = {}
    
    @lru_cache(maxsize=100)
    def _cached_api_call(self, endpoint: str):
        if endpoint not in self._cache:
            self._cache[endpoint] = time.time()
            # 执行 API 调用
            result = self._make_api_call(endpoint)
            return result
        else:
            return self._cache[endpoint]
    
    def _run(self, endpoint: str):
        return self._cached_api_call(endpoint)
```

### 2. 异步工具支持
```python
from crewai.tools import BaseTool
import asyncio
from typing import Any

class AsyncTool(BaseTool):
    async def _arun(self, **kwargs) -> Any:
        # 异步工具逻辑
        result = await self.perform_async_operation(**kwargs)
        return result
    
    async def perform_async_operation(self, **kwargs):
        # 具体的异步实现
        await asyncio.sleep(1)  # 模拟异步操作
        return {"result": "异步操作完成"}
```

### 3. 批量处理工具
```python
from crewai.tools import BaseTool
from typing import List

class BatchProcessorTool(BaseTool):
    def _run(self, items: List[str]):
        results = []
        for item in items:
            result = self.process_item(item)
            results.append(result)
        return {"processed_items": results}
    
    def process_item(self, item: str):
        # 单项处理逻辑
        return f"已处理：{item}"
```

## 工具最佳实践

### 1. 明确的工具描述
```python
# ✅ 良好
@tool
def data_analyzer(data: str) -> dict:
    """分析数据集并返回统计信息。
    
    参数：
    - data: 要分析的原始数据（字符串格式）
    
    返回：
    - 包含以下键的字典：
      - record_count: 记录数量
      - data_types: 检测到的数据类型
      - quality_score: 数据质量评分
    """
    # 实现逻辑
    return analysis_result

# ❌ 避免
@tool
def process_data(data: str) -> dict:
    """处理数据。"""  # 过于简单
```

### 2. 合理的错误处理
```python
from crewai.tools import BaseTool
import logging

class RobustTool(BaseTool):
    def _run(self, **kwargs):
        try:
            # 验证输入
            validated_input = self.validate_input(**kwargs)
            # 执行主要逻辑
            result = self.perform_operation(validated_input)
            return result
        except ValueError as e:
            logging.warning(f"输入验证失败：{e}")
            return {"error": f"无效输入：{e}"}
        except Exception as e:
            logging.error(f"工具执行失败：{e}")
            return {"error": f"系统错误：{e}"}
    
    def validate_input(self, **kwargs):
        # 实现验证逻辑
        return kwargs  # 示例
```

### 3. 幂等性设计
```python
from crewai.tools import BaseTool

class IdempotentFileTool(BaseTool):
    def _run(self, file_path: str, content: str):
        # 检查文件是否已存在且内容相同
        if self.file_exists_and_matches(file_path, content):
            return {"status": "文件已存在且内容相同，无需操作"}
        else:
            return self.write_file(file_path, content)
```

### 4. 工具测试
```python
import unittest
from crewai.tools import BaseTool

class TestableTool(BaseTool):
    def _run(self, test_input: str):
        return self.process(test_input)
    
    def process(self, input_data: str):
        # 主要处理逻辑
        return input_data.upper()

class TestTool(unittest.TestCase):
    def setUp(self):
        self.tool = TestableTool()
    
    def test_upper_case(self):
        result = self.tool._run("hello world")
        self.assertEqual(result["result"], "HELLO WORLD")
```

## 工具和代理集成

### 在代理中使用工具
```python
from crewai import Agent, Crew, Task

agent = Agent(
    role="数据分析师",
    goal="分析和处理数据",
    tools=[file_reader, data_processor, web_search],
    llm=LLM(model="gpt-4")
)

task = Task(
    description="分析销售数据文件",
    expected_output="详细的销售分析报告",
    agent=agent
)
```

### 任务特定的工具配置
```python
# 在任务级别覆盖代理的工具集
task = Task(
    description="执行 API 集成任务",
    agent=agent,  # 使用代理的默认工具
    tools=[api_integration_tool],  # 为此任务特定指定额外的工具
)
```

工具系统为 CrewAI 代理提供了强大的扩展能力，使其能够与外部世界交互并执行复杂的操作。通过正确使用工具，您可以创建能够处理真实世界场景的强大 AI 代理。