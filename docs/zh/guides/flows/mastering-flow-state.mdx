---
title: 掌握 Flow 状态管理
description: 关于在 CrewAI Flows 中管理、持久化和利用状态构建强大 AI 应用程序的全面指南。
icon: diagram-project
mode: "wide"
---

## 理解 Flows 中状态的力量

状态管理是任何复杂 AI 工作流程的骨干。在 CrewAI Flows 中，状态系统允许你维护上下文、在步骤之间共享数据，并构建复杂的应用程序逻辑。掌握状态管理对于创建可靠、可维护和强大的 AI 应用程序至关重要。

本指南将引导你了解在 CrewAI Flows 中管理状态所需的一切，从基本概念到高级技术，并提供实际代码示例。

### 为什么状态管理很重要

有效的状态管理使你能够：

1. **在执行步骤之间维护上下文** - 在工作流程的不同阶段之间无缝传递信息
2. **构建复杂的条件逻辑** - 基于累积数据做出决策
3. **创建持久化应用程序** - 保存和恢复工作流程进度
4. **优雅地处理错误** - 为更强大的应用程序实现恢复模式
5. **扩展你的应用程序** - 支持具有适当数据组织的复杂工作流程
6. **启用对话式应用程序** - 存储和访问对话历史以实现上下文感知的 AI 交互

让我们探索如何有效利用这些能力。

## 状态管理基础

### Flow 状态生命周期

在 CrewAI Flows 中，状态遵循可预测的生命周期：

1. **初始化** - 当 flow 被创建时，其状态被初始化（作为空字典或 Pydantic 模型实例）
2. **修改** - Flow 方法在执行时访问和修改状态
3. **传递** - 状态在 flow 方法之间自动传递
4. **持久化**（可选）- 状态可以保存到存储中并在以后检索
5. **完成** - 最终状态反映了所有执行方法的累积更改

理解这个生命周期对于设计有效的 flows 至关重要。

### 状态管理的两种方法

CrewAI 提供两种方法来在你的 flows 中管理状态：

1. **非结构化状态** - 使用类字典对象实现灵活性
2. **结构化状态** - 使用 Pydantic 模型实现类型安全和验证

让我们详细检查每种方法。

## 非结构化状态管理

非结构化状态使用类字典的方法，为简单应用程序提供灵活性和简便性。

### 它如何工作

使用非结构化状态时：
- 你通过 `self.state` 访问状态，它的行为类似于字典
- 你可以在任何时候自由添加、修改或删除键
- 所有状态自动可用于所有 flow 方法

### 基本示例

这是一个非结构化状态管理的简单示例：

```python
from crewai.flow.flow import Flow, listen, start

class UnstructuredStateFlow(Flow):
    @start()
    def initialize_data(self):
        print("初始化 flow 数据")
        # 添加键值对到状态
        self.state["user_name"] = "Alex"
        self.state["preferences"] = {
            "theme": "dark",
            "language": "English"
        }
        self.state["items"] = []

        # flow 状态自动获得唯一 ID
        print(f"Flow ID: {self.state['id']}")

        return "已初始化"

    @listen(initialize_data)
    def process_data(self, previous_result):
        print(f"上一步返回：{previous_result}")

        # 访问和修改状态
        user = self.state["user_name"]
        print(f"正在为{user}处理数据")

        # 将项目添加到状态中的列表
        self.state["items"].append("item1")
        self.state["items"].append("item2")

        # 添加新的键值对
        self.state["processed"] = True

        return "已处理"

    @listen(process_data)
    def generate_summary(self, previous_result):
        # 访问多个状态值
        user = self.state["user_name"]
        theme = self.state["preferences"]["theme"]
        items = self.state["items"]
        processed = self.state.get("processed", False)

        summary = f"用户{user}有{len(items)}个项目，使用{theme}主题。"
        summary += "数据已处理。" if processed else "数据未处理。"

        return summary

# 运行 flow
flow = UnstructuredStateFlow()
result = flow.kickoff()
print(f"最终结果：{result}")
print(f"最终状态：{flow.state}")
```

### 何时使用非结构化状态

非结构化状态理想用于：
- 快速原型化和简单 flows
- 动态演变的状态需求
- 结构可能事先不知道的情况
- 具有简单状态需求的 flows

虽然灵活，但非结构化状态缺乏类型检查和模式验证，这可能导致复杂应用程序中的错误。

## 结构化状态管理

结构化状态使用 Pydantic 模型为你的 flow 状态定义模式，提供类型安全、验证和更好的开发体验。

### 它如何工作

使用结构化状态时：
- 你定义一个代表你的状态结构的 Pydantic 模型
- 你将此模型类型作为类型参数传递给你的 Flow 类
- 你通过 `self.state` 访问状态，它的行为类似于 Pydantic 模型实例
- 所有字段根据其定义的类型进行验证
- 你获得 IDE 自动完成和类型检查支持

### 基本示例

这里是如何实现结构化状态管理：

```python
from crewai.flow.flow import Flow, listen, start
from pydantic import BaseModel, Field
from typing import List, Dict, Optional

# 定义你的状态模型
class UserPreferences(BaseModel):
    theme: str = "light"
    language: str = "English"

class AppState(BaseModel):
    user_name: str = ""
    preferences: UserPreferences = UserPreferences()
    items: List[str] = []
    processed: bool = False
    completion_percentage: float = 0.0

# 创建带类型化状态的 flow
class StructuredStateFlow(Flow[AppState]):
    @start()
    def initialize_data(self):
        print("初始化 flow 数据")
        # 设置状态值（类型检查）
        self.state.user_name = "Taylor"
        self.state.preferences.theme = "dark"

        # ID 字段自动可用
        print(f"Flow ID: {self.state.id}")

        return "已初始化"

    @listen(initialize_data)
    def process_data(self, previous_result):
        print(f"正在为{self.state.user_name}处理数据")

        # 修改状态（带类型检查）
        self.state.items.append("item1")
        self.state.items.append("item2")
        self.state.processed = True
        self.state.completion_percentage = 50.0

        return "已处理"

    @listen(process_data)
    def generate_summary(self, previous_result):
        # 访问状态（带自动完成）
        summary = f"用户{self.state.user_name}有{len(self.state.items)}个项目"
        summary += f"，使用{self.state.preferences.theme}主题。"
        summary += "数据已处理。" if self.state.processed else "数据未处理。"
        summary += f" 完成：{self.state.completion_percentage}%"

        return summary

# 运行 flow
flow = StructuredStateFlow()
result = flow.kickoff()
print(f"最终结果：{result}")
print(f"最终状态：{flow.state}")
```

### 结构化状态的好处

使用结构化状态提供了几个优势：

1. **类型安全** - 在开发时捕获类型错误
2. **自文档化** - 状态模型清楚记录了可用的数据
3. **验证** - 数据类型和约束的自动验证
4. **IDE 支持** - 获得自动完成和内联文档
5. **默认值** - 轻松定义缺失数据的回退

### 何时使用结构化状态

结构化状态推荐用于：
- 具有明确定义数据模式的复杂 flows
- 多个开发人员在同一代码上工作的团队项目
- 数据验证很重要的应用程序
- 需要强制特定数据类型和约束的 flows

## 自动状态 ID

非结构化和结构化状态都自动接收唯一标识符（UUID）以帮助跟踪和管理状态实例。

### 它如何工作

- 对于非结构化状态，ID 可作为 `self.state["id"]` 访问
- 对于结构化状态，ID 可作为 `self.state.id` 访问
- 此 ID 在 flow 被创建时自动生成
- ID 在 flow 的整个生命周期中保持相同
- ID 可用于跟踪、日志记录和检索持久化状态

这个 UUID 在实现持久化或跟踪多个 flow 执行时特别有价值。

## 动态状态更新

无论你使用结构化还是非结构化状态，你都可以在你的 flow 执行期间动态更新状态。

### 在步骤之间传递数据

Flow 方法可以返回值，然后作为参数传递给监听方法：

```python
from crewai.flow.flow import Flow, listen, start

class DataPassingFlow(Flow):
    @start()
    def generate_data(self):
        # 此返回值将传递给监听方法
        return "生成的数据"

    @listen(generate_data)
    def process_data(self, data_from_previous_step):
        print(f"收到：{data_from_previous_step}")
        # 你可以修改数据并继续传递
        processed_data = f"{data_from_previous_step} - 已处理"
        # 同时更新状态
        self.state["last_processed"] = processed_data
        return processed_data

    @listen(process_data)
    def finalize_data(self, processed_data):
        print(f"收到已处理数据：{processed_data}")
        # 访问传递的数据和状态
        last_processed = self.state.get("last_processed", "")
        return f"最终：{processed_data}（来自状态：{last_processed}）"
```

这种模式允许你结合直接数据传递和状态更新以获得最大灵活性。

## 持久化 Flow 状态

CrewAI 最强大的功能之一是能够在执行之间持久化 flow 状态。这使得可以暂停、恢复甚至失败后恢复的工作流程。

### @persist() 装饰器

`@persist()` 装饰器自动化状态持久化，在执行的关键点保存你的 flow 状态。

#### 类级别持久化

当应用于类级别时，`@persist()` 在每次方法执行后保存状态：

```python
from crewai.flow.flow import Flow, listen, start
from crewai.flow.persistence import persist
from pydantic import BaseModel

class CounterState(BaseModel):
    value: int = 0

@persist()  # 应用于整个 flow 类
class PersistentCounterFlow(Flow[CounterState]):
    @start()
    def increment(self):
        self.state.value += 1
        print(f"增加到{self.state.value}")
        return self.state.value

    @listen(increment)
    def double(self, value):
        self.state.value = value * 2
        print(f"加倍到{self.state.value}")
        return self.state.value

# 第一次运行
flow1 = PersistentCounterFlow()
result1 = flow1.kickoff()
print(f"第一次运行结果：{result1}")

# 第二次运行 - 状态自动加载
flow2 = PersistentCounterFlow()
result2 = flow2.kickoff()
print(f"第二次运行结果：{result2}")  # 由于持久化状态会更高
```

#### 方法级别持久化

为了更精细的控制，你可以将 `@persist()` 应用于特定方法：

```python
from crewai.flow.flow import Flow, listen, start
from crewai.flow.persistence import persist

class SelectivePersistFlow(Flow):
    @start()
    def first_step(self):
        self.state["count"] = 1
        return "第一步"

    @persist()  # 只在此方法后持久化
    @listen(first_step)
    def important_step(self, prev_result):
        self.state["count"] += 1
        self.state["important_data"] = "这将被持久化"
        return "重要步骤已完成"

    @listen(important_step)
    def final_step(self, prev_result):
        self.state["count"] += 1
        return f"完成，计数{self.state['count']}"
```

## 高级状态模式

### 条件启动和可恢复执行

Flows 支持条件 `@start()` 和可恢复执行用于 HITL/循环场景：

```python
from crewai.flow.flow import Flow, start, listen, and_, or_

class ResumableFlow(Flow):
    @start()  # 无条件启动
    def init(self):
        ...

    # 条件启动：在"init"或外部触发器名称后运行
    @start("init")
    def maybe_begin(self):
        ...

    @listen(and_(init, maybe_begin))
    def proceed(self):
        ...
```

- 条件 `@start()` 接受方法名、路由器标签或可调用条件。
- 在恢复期间，监听器从先前的检查点继续；循环/路由器分支尊重恢复标志。

### 基于状态的条件逻辑

你可以使用状态在你的 flows 中实现复杂的条件逻辑：

```python
from crewai.flow.flow import Flow, listen, router, start
from pydantic import BaseModel

class PaymentState(BaseModel):
    amount: float = 0.0
    is_approved: bool = False
    retry_count: int = 0

class PaymentFlow(Flow[PaymentState]):
    @start()
    def process_payment(self):
        # 模拟支付处理
        self.state.amount = 100.0
        self.state.is_approved = self.state.amount < 1000
        return "支付已处理"

    @router(process_payment)
    def check_approval(self, previous_result):
        if self.state.is_approved:
            return "approved"
        elif self.state.retry_count < 3:
            return "retry"
        else:
            return "rejected"

    @listen("approved")
    def handle_approval(self):
        return f"${self.state.amount}的付款已批准！"

    @listen("retry")
    def handle_retry(self):
        self.state.retry_count += 1
        print(f"重试支付（尝试{self.state.retry_count}）...")
        # 可以在这里实现重试逻辑
        return "已启动重试"

    @listen("rejected")
    def handle_rejection(self):
        return f"${self.state.amount}的付款在{self.state.retry_count}次重试后被拒绝。"
```

### 处理复杂状态转换

对于复杂的状态转换，你可以创建专门的方法：

```python
from crewai.flow.flow import Flow, listen, start
from pydantic import BaseModel
from typing import List, Dict

class UserData(BaseModel):
    name: str
    active: bool = True
    login_count: int = 0

class ComplexState(BaseModel):
    users: Dict[str, UserData] = {}
    active_user_count: int = 0

class TransformationFlow(Flow[ComplexState]):
    @start()
    def initialize(self):
        # 添加一些用户
        self.add_user("alice", "Alice")
        self.add_user("bob", "Bob")
        self.add_user("charlie", "Charlie")
        return "已初始化"

    @listen(initialize)
    def process_users(self, _):
        # 增加登录次数
        for user_id in self.state.users:
            self.increment_login(user_id)

        # 停用一个用户
        self.deactivate_user("bob")

        # 更新活跃计数
        self.update_active_count()

        return f"已处理{len(self.state.users)}个用户"

    # 状态转换的辅助方法
    def add_user(self, user_id: str, name: str):
        self.state.users[user_id] = UserData(name=name)
        self.update_active_count()

    def increment_login(self, user_id: str):
        if user_id in self.state.users:
            self.state.users[user_id].login_count += 1

    def deactivate_user(self, user_id: str):
        if user_id in self.state.users:
            self.state.users[user_id].active = False
            self.update_active_count()

    def update_active_count(self):
        self.state.active_user_count = sum(
            1 for user in self.state.users.values() if user.active
        )
```

这种创建辅助方法的模式使你的 flow 方法保持干净，同时启用复杂的状态操作。

## 与 Crews 的状态管理

CrewAI 中最强大的模式之一是将 flow 状态管理与 crew 执行结合起来。

### 将状态传递给 Crews

你可以使用 flow 状态来参数化 crews：

```python
from crewai.flow.flow import Flow, listen, start
from crewai import Agent, Crew, Process, Task
from pydantic import BaseModel

class ResearchState(BaseModel):
    topic: str = ""
    depth: str = "medium"
    results: str = ""

class ResearchFlow(Flow[ResearchState]):
    @start()
    def get_parameters(self):
        # 在实际应用中，这可能来自用户输入
        self.state.topic = "人工智能伦理"
        self.state.depth = "deep"
        return "参数已设置"

    @listen(get_parameters)
    def execute_research(self, _):
        # 创建智能体
        researcher = Agent(
            role="研究专家",
            goal=f"以{self.state.depth}细节研究{self.state.topic}",
            backstory="你是一名具有查找准确信息才能的专业研究员。"
        )

        writer = Agent(
            role="内容写作者",
            goal="将研究转化为清晰、引人入胜的内容",
            backstory="你擅长清晰简洁地传达复杂想法。"
        )

        # 创建任务
        research_task = Task(
            description=f"以{self.state.depth}分析研究{self.state.topic}",
            expected_output="markdown 格式的全面研究笔记",
            agent=researcher
        )

        writing_task = Task(
            description=f"根据研究创建关于{self.state.topic}的摘要",
            expected_output="markdown 格式的优秀文章",
            agent=writer,
            context=[research_task]
        )

        # 创建并运行 crew
        research_crew = Crew(
            agents=[researcher, writer],
            tasks=[research_task, writing_task],
            process=Process.sequential,
            verbose=True
        )

        # 运行 crew 并将结果存储在状态中
        result = research_crew.kickoff()
        self.state.results = result.raw

        return "研究已完成"

    @listen(execute_research)
    def summarize_results(self, _):
        # 访问存储的结果
        result_length = len(self.state.results)
        return f"关于{self.state.topic}的研究已完成，包含{result_length}个字符的结果。"
```

### 在状态中处理 Crew 输出

当 crew 完成时，你可以处理其输出并将其存储在你的 flow 状态中：

```python
@listen(execute_crew)
def process_crew_results(self, _):
    # 解析原始结果（假设 JSON 输出）
    import json
    try:
        results_dict = json.loads(self.state.raw_results)
        self.state.processed_results = {
            "title": results_dict.get("title", ""),
            "main_points": results_dict.get("main_points", []),
            "conclusion": results_dict.get("conclusion", "")
        }
        return "结果已成功处理"
    except json.JSONDecodeError:
        self.state.error = "无法将 crew 结果解析为 JSON"
        return "处理结果时出错"
```

## 状态管理的最佳实践

### 1. 保持状态专注

设计你的状态只包含必要的内容：

```python
# 太宽泛
class BloatedState(BaseModel):
    user_data: Dict = {}
    system_settings: Dict = {}
    temporary_calculations: List = []
    debug_info: Dict = {}
    # ...更多字段

# 更好：专注的状态
class FocusedState(BaseModel):
    user_id: str
    preferences: Dict[str, str]
    completion_status: Dict[str, bool]
```

### 2. 对复杂 Flows 使用结构化状态

随着你的 flows 在复杂性上增长，结构化状态变得越来越有价值：

```python
# 简单 flow 可以使用非结构化状态
class SimpleGreetingFlow(Flow):
    @start()
    def greet(self):
        self.state["name"] = "World"
        return f"Hello, {self.state['name']}!"

# 复杂 flow 受益于结构化状态
class UserRegistrationState(BaseModel):
    username: str
    email: str
    verification_status: bool = False
    registration_date: datetime = Field(default_factory=datetime.now)
    last_login: Optional[datetime] = None

class RegistrationFlow(Flow[UserRegistrationState]):
    # 带有强类型状态访问的方法
```

### 3. 记录状态转换

对于复杂的 flows，记录状态在整个执行过程中如何变化：

```python
@start()
def initialize_order(self):
    """
    用空值初始化订单状态。

    之前状态：{}
    之后状态：{order_id: str, items: [], status: 'new'}
    """
    self.state.order_id = str(uuid.uuid4())
    self.state.items = []
    self.state.status = "new"
    return "订单已初始化"
```

### 4. 优雅地处理状态错误

为状态访问实现错误处理：

```python
@listen(previous_step)
def process_data(self, _):
    try:
        # 尝试访问可能不存在的值
        user_preference = self.state.preferences.get("theme", "default")
    except (AttributeError, KeyError):
        # 优雅地处理错误
        self.state.errors = self.state.get("errors", [])
        self.state.errors.append("无法访问偏好")
        user_preference = "default"

    return f"使用了偏好：{user_preference}"
```

### 5. 使用状态进行进度跟踪

利用状态跟踪长时间运行的 flows 中的进度：

```python
class ProgressTrackingFlow(Flow):
    @start()
    def initialize(self):
        self.state["total_steps"] = 3
        self.state["current_step"] = 0
        self.state["progress"] = 0.0
        self.update_progress()
        return "已初始化"

    def update_progress(self):
        """辅助方法来计算和更新进度"""
        if self.state.get("total_steps", 0) > 0:
            self.state["progress"] = (self.state.get("current_step", 0) /
                                    self.state["total_steps"]) * 100
            print(f"进度：{self.state['progress']:.1f}%")

    @listen(initialize)
    def step_one(self, _):
        # 做工作...
        self.state["current_step"] = 1
        self.update_progress()
        return "步骤 1 完成"

    # 其他步骤...
```

### 6. 尽可能使用不可变操作

特别是对于结构化状态，优先使用不可变操作以实现清晰性：

```python
# 而不是就地修改列表：
self.state.items.append(new_item)  # 可变操作

# 考虑创建新状态：
from pydantic import BaseModel
from typing import List

class ItemState(BaseModel):
    items: List[str] = []

class ImmutableFlow(Flow[ItemState]):
    @start()
    def add_item(self):
        # 创建带有添加项目的新列表
        self.state.items = [*self.state.items, "new item"]
        return "项目已添加"
```

## 调试 Flow 状态

### 记录状态更改

在开发时，添加日志记录来跟踪状态更改：

```python
import logging
logging.basicConfig(level=logging.INFO)

class LoggingFlow(Flow):
    def log_state(self, step_name):
        logging.info(f"{step_name}后的状态：{self.state}")

    @start()
    def initialize(self):
        self.state["counter"] = 0
        self.log_state("initialize")
        return "已初始化"

    @listen(initialize)
    def increment(self, _):
        self.state["counter"] += 1
        self.log_state("increment")
        return f"增加到{self.state['counter']}"
```

### 状态可视化

你可以添加方法来可视化你的状态用于调试：

```python
def visualize_state(self):
    """创建当前状态的简单可视化"""
    import json
    from rich.console import Console
    from rich.panel import Panel

    console = Console()

    if hasattr(self.state, "model_dump"):
        # Pydantic v2
        state_dict = self.state.model_dump()
    elif hasattr(self.state, "dict"):
        # Pydantic v1
        state_dict = self.state.dict()
    else:
        # 非结构化状态
        state_dict = dict(self.state)

    # 为更清晰的输出移除 id
    if "id" in state_dict:
        state_dict.pop("id")

    state_json = json.dumps(state_dict, indent=2, default=str)
    console.print(Panel(state_json, title="当前 Flow 状态"))
```

## 结论

掌握 CrewAI Flows 中的状态管理使你能够构建复杂、强大的 AI 应用程序，这些应用程序维护上下文、做出复杂决策并提供一致的结果。

无论你选择非结构化还是结构化状态，实施适当的状态管理实践将帮助你创建可维护、可扩展且有效解决现实问题的 flows。

随着你开发更复杂的 flows，记住良好的状态管理是在灵活性和结构之间找到正确的平衡，使你的代码既强大又易于理解。

<Check>
你现在已掌握了 CrewAI Flows 中状态管理的概念和实践！有了这些知识，你可以创建有效维护上下文、在步骤之间共享数据并构建复杂应用程序逻辑的强大 AI 工作流程。
</Check>

## 下一步

- 在你的 flows 中试验结构化和非结构化状态
- 尝试为长时间运行的工作流程实现状态持久化
- 探索[构建你的第一个 crew](/zh/guides/crews/first-crew)以了解 crews 和 flows 如何协同工作
- 查看[Flow 参考文档](/zh/concepts/flows)以获得更多高级功能