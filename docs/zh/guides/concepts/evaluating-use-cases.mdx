---
title: 评估 CrewAI 的用例
description: 学习如何评估你的 AI 应用需求，并根据复杂性和精度要求选择 Crews 和 Flows 之间的正确方法。
icon: scale-balanced
mode: "wide"
---

## 理解决策框架

当使用 CrewAI 构建 AI 应用程序时，最重要的决策之一是为你的特定用例选择正确的方法。你应该使用 Crew？还是 Flow？还是两者的组合？本指南将帮助你评估你的需求并做出明智的架构决策。

这个决策的核心是理解你的应用程序中**复杂性**和**精度**之间的关系：

<Frame caption="CrewAI 应用程序的复杂性 vs. 精度矩阵">
  <img src="/images/complexity_precision.png" alt="复杂性 vs. 精度矩阵" />
</Frame>

这个矩阵帮助可视化不同方法如何与不同的复杂性和精度要求对齐。让我们探索每个象限意味着什么，以及它如何指导你的架构选择。

## 复杂性-精度矩阵解释

### 什么是复杂性？

在 CrewAI 应用程序的背景下，**复杂性**指的是：

- 所需的不同步骤或操作的数量
- 需要执行的任务的多样性
- 不同组件之间的相互依赖性
- 对条件逻辑和分支的需求
- 整体工作流程的复杂性

### 什么是精度？

**精度**在这个背景下指的是：

- 最终输出所需的准确性
- 对结构化、可预测结果的需求
- 可重现性的重要性
- 对每个步骤所需控制的水平
- 对输出变化的容忍度

### 四个象限

#### 1. 低复杂性，低精度

**特征：**
- 简单、直接的任务
- 对输出变化有一定容忍度
- 有限的步骤数
- 创意或探索性应用

**推荐方法：** 使用最少智能体的简单 Crews

**示例用例：**
- 基本内容生成
- 创意头脑风暴
- 简单摘要任务
- 创意写作辅助

#### 2. 低复杂性，高精度

**特征：**
- 需要精确、结构化输出的简单工作流程
- 对可重现结果的需求
- 步骤有限但准确性要求高
- 通常涉及数据处理或转换

**推荐方法：** 带有直接 LLM 调用或具有结构化输出的简单 Crews 的 Flows

**示例用例：**
- 数据提取和转换
- 表单填写和验证
- 结构化内容生成（JSON、XML）
- 简单分类任务

#### 3. 高复杂性，低精度

**特征：**
- 具有许多步骤的多阶段过程
- 创意或探索性输出
- 组件之间的复杂交互
- 对最终结果变化有容忍度

**推荐方法：** 具有多个专业化智能体的复杂 Crews

**示例用例：**
- 研究和分析
- 内容创建管道
- 探索性数据分析
- 创意问题解决

#### 4. 高复杂性，高精度

**特征：**
- 需要结构化输出的复杂工作流程
- 具有严格准确性要求的多个相互依赖步骤
- 需要复杂处理和精确结果
- 通常是关键任务应用

**推荐方法：** 编排多个 Crews 带验证步骤的 Flows

**示例用例：**
- 企业决策支持系统
- 复杂数据处理管道
- 多阶段文档处理
- 受监管行业应用

## 在 Crews 和 Flows 之间选择

### 何时选择 Crews

Crews 在以下情况下理想：

1. **你需要协作智能** - 具有不同专业化的多个智能体需要协同工作
2. **问题需要涌现思维** - 解决方案受益于不同视角和方法
3. **任务主要是创意或分析性的** - 工作涉及研究、内容创建或分析
4. **你重视适应性而非严格结构** - 工作流程可以从智能体自主性中受益
5. **输出格式可以有一定灵活性** - 输出结构的一些变化是可接受的

```python
# 示例：用于市场分析的研究 Crew
from crewai import Agent, Crew, Process, Task

# 创建专业化智能体
researcher = Agent(
    role="市场研究专家",
    goal="查找关于新兴技术的全面市场数据",
    backstory="你是一名发现市场趋势和收集数据的专家。"
)

analyst = Agent(
    role="市场分析师",
    goal="分析市场数据并识别关键机会",
    backstory="你擅长解释市场数据和发现有价值的洞察。"
)

# 定义他们的任务
research_task = Task(
    description="研究 AI 驱动的医疗保健解决方案的当前市场格局",
    expected_output="包含关键参与者、市场规模和增长趋势的全面市场数据",
    agent=researcher
)

analysis_task = Task(
    description="分析市场数据并识别前 3 个投资机会",
    expected_output="带有 3 个推荐投资机会和理由的分析报告",
    agent=analyst,
    context=[research_task]
)

# 创建 crew
market_analysis_crew = Crew(
    agents=[researcher, analyst],
    tasks=[research_task, analysis_task],
    process=Process.sequential,
    verbose=True
)

# 运行 crew
result = market_analysis_crew.kickoff()
```

### 何时选择 Flows

Flows 在以下情况下理想：

1. **你需要对执行的精确控制** - 工作流程需要精确排序和状态管理
2. **应用程序具有复杂的状态需求** - 你需要在多个步骤之间维护和转换状态
3. **你需要结构化、可预测的输出** - 应用程序需要一致的、格式化的结果
4. **工作流程涉及条件逻辑** - 需要基于中间结果采取不同路径
5. **你需要将 AI 与过程代码结合** - 解决方案既需要 AI 能力也需要传统编程

```python
# 示例：具有结构化处理的客户支持 Flow
from crewai.flow.flow import Flow, listen, router, start
from pydantic import BaseModel
from typing import List, Dict

# 定义结构化状态
class SupportTicketState(BaseModel):
    ticket_id: str = ""
    customer_name: str = ""
    issue_description: str = ""
    category: str = ""
    priority: str = "medium"
    resolution: str = ""
    satisfaction_score: int = 0

class CustomerSupportFlow(Flow[SupportTicketState]):
    @start()
    def receive_ticket(self):
        # 在实际应用中，这可能来自 API
        self.state.ticket_id = "TKT-12345"
        self.state.customer_name = "Alex Johnson"
        self.state.issue_description = "付款后无法访问高级功能"
        return "票证已收到"

    @listen(receive_ticket)
    def categorize_ticket(self, _):
        # 使用直接 LLM 调用进行分类
        from crewai import LLM
        llm = LLM(model="openai/gpt-4o-mini")

        prompt = f"""
        将以下客户支持问题分类到这些类别之一：
        - 计费
        - 账户访问
        - 技术问题
        - 功能请求
        - 其他

        问题：{self.state.issue_description}

        只返回类别名称。
        """

        self.state.category = llm.call(prompt).strip()
        return self.state.category

    @router(categorize_ticket)
    def route_by_category(self, category):
        # 根据类别路由到不同的处理程序
        return category.lower().replace(" ", "_")

    @listen("billing")
    def handle_billing_issue(self):
        # 处理计费特定逻辑
        self.state.priority = "high"
        # 更多计费特定处理...
        return "计费问题已处理"

    @listen("account_access")
    def handle_access_issue(self):
        # 处理访问特定逻辑
        self.state.priority = "high"
        # 更多访问特定处理...
        return "访问问题已处理"

    # 其他类别处理程序...

    @listen("billing", "account_access", "technical_issue", "feature_request", "other")
    def resolve_ticket(self, resolution_info):
        # 最终解决步骤
        self.state.resolution = f"问题已解决：{resolution_info}"
        return self.state.resolution

# 运行 flow
support_flow = CustomerSupportFlow()
result = support_flow.kickoff()
```

### 何时结合 Crews 和 Flows

最复杂的应用程序通常受益于结合 Crews 和 Flows：

1. **复杂的多阶段过程** - 使用 Flows 编排整体过程，使用 Crews 处理复杂子任务
2. **需要创意和结构的应用程序** - 使用 Crews 进行创意任务，使用 Flows 进行结构化处理
3. **企业级 AI 应用程序** - 使用 Flows 管理状态和过程流，同时利用 Crews 进行专业化工作

```python
# 示例：结合 Crews 和 Flows 的内容生产管道
from crewai.flow.flow import Flow, listen, start
from crewai import Agent, Crew, Process, Task
from pydantic import BaseModel
from typing import List, Dict

class ContentState(BaseModel):
    topic: str = ""
    target_audience: str = ""
    content_type: str = ""
    outline: Dict = {}
    draft_content: str = ""
    final_content: str = ""
    seo_score: int = 0

class ContentProductionFlow(Flow[ContentState]):
    @start()
    def initialize_project(self):
        # 设置初始参数
        self.state.topic = "可持续投资"
        self.state.target_audience = "千禧一代投资者"
        self.state.content_type = "博客文章"
        return "项目已初始化"

    @listen(initialize_project)
    def create_outline(self, _):
        # 使用研究 crew 创建大纲
        researcher = Agent(
            role="内容研究员",
            goal=f"为{self.state.target_audience}研究{self.state.topic}",
            backstory="你是一名具有内容创建深厚知识的专业研究员。"
        )

        outliner = Agent(
            role="内容策略师",
            goal=f"为{self.state.content_type}创建引人入胜的大纲",
            backstory="你擅长为最大参与度构建内容结构。"
        )

        research_task = Task(
            description=f"研究{self.state.topic}，专注于{self.state.target_audience}感兴趣的内容",
            expected_output="带要点和统计数据的全面研究笔记",
            agent=researcher
        )

        outline_task = Task(
            description=f"为关于{self.state.topic}的{self.state.content_type}创建大纲",
            expected_output="带有部分和要点的详细内容大纲",
            agent=outliner,
            context=[research_task]
        )

        outline_crew = Crew(
            agents=[researcher, outliner],
            tasks=[research_task, outline_task],
            process=Process.sequential,
            verbose=True
        )

        # 运行 crew 并存储结果
        result = outline_crew.kickoff()

        # 解析大纲（在实际应用中，你可能使用更强大的解析方法）
        import json
        try:
            self.state.outline = json.loads(result.raw)
        except:
            # 如果不是有效 JSON 则回退
            self.state.outline = {"sections": result.raw}

        return "大纲已创建"

    @listen(create_outline)
    def write_content(self, _):
        # 使用写作 crew 创建内容
        writer = Agent(
            role="内容写作者",
            goal=f"为{self.state.target_audience}撰写引人入胜的内容",
            backstory="你是一名撰写引人入胜内容的熟练写作者。"
        )

        editor = Agent(
            role="内容编辑",
            goal="确保内容精炼、准确且引人入胜",
            backstory="你对细节有敏锐眼光并有改进内容的才能。"
        )

        writing_task = Task(
            description=f"按照此大纲撰写关于{self.state.topic}的{self.state.content_type}：{self.state.outline}",
            expected_output="markdown 格式的完整草稿内容",
            agent=writer
        )

        editing_task = Task(
            description="编辑和改进草稿内容的清晰度、参与度和准确性",
            expected_output="markdown 格式的精炼最终内容",
            agent=editor,
            context=[writing_task]
        )

        writing_crew = Crew(
            agents=[writer, editor],
            tasks=[writing_task, editing_task],
            process=Process.sequential,
            verbose=True
        )

        # 运行 crew 并存储结果
        result = writing_crew.kickoff()
        self.state.final_content = result.raw

        return "内容已创建"

    @listen(write_content)
    def optimize_for_seo(self, _):
        # 使用直接 LLM 调用进行 SEO 优化
        from crewai import LLM
        llm = LLM(model="openai/gpt-4o-mini")

        prompt = f"""
        分析此内容对关键词"{self.state.topic}"的 SEO 效果。
        在 1-100 的范围内评分，并提供 3 个具体的改进建议。

        内容：{self.state.final_content[:1000]}...（为简洁而截断）

        按以下结构格式化你的回复为 JSON：
        {{
            "score": 85,
            "recommendations": [
                "建议 1",
                "建议 2",
                "建议 3"
            ]
        }}
        """

        seo_analysis = llm.call(prompt)

        # 解析 SEO 分析
        import json
        try:
            analysis = json.loads(seo_analysis)
            self.state.seo_score = analysis.get("score", 0)
            return analysis
        except:
            self.state.seo_score = 50
            return {"score": 50, "recommendations": ["无法解析 SEO 分析"]}

# 运行 flow
content_flow = ContentProductionFlow()
result = content_flow.kickoff()
```

## 实践评估框架

要为你的特定用例确定正确方法，请遵循这个逐步评估框架：

### 步骤 1：评估复杂性

通过考虑以下因素，在 1-10 的范围内评估你应用程序的复杂性：

1. **步骤数量**：需要多少不同的操作？
   - 1-3 步骤：低复杂性（1-3）
   - 4-7 步骤：中等复杂性（4-7）
   - 8+ 步骤：高复杂性（8-10）

2. **相互依赖性**：不同部分之间有多少关联？
   - 少量依赖：低复杂性（1-3）
   - 一些依赖：中等复杂性（4-7）
   - 许多复杂依赖：高复杂性（8-10）

3. **条件逻辑**：需要多少分支和决策？
   - 线性过程：低复杂性（1-3）
   - 一些分支：中等复杂性（4-7）
   - 复杂决策树：高复杂性（8-10）

4. **领域知识**：所需的知识有多专业化？
   - 通用知识：低复杂性（1-3）
   - 一些专业知识：中等复杂性（4-7）
   - 多个领域的深厚专业知识：高复杂性（8-10）

计算你的平均分数以确定整体复杂性。

### 步骤 2：评估精度要求

通过考虑以下因素，在 1-10 的范围内评估你的精度要求：

1. **输出结构**：输出必须有多少结构化？
   - 自由格式文本：低精度（1-3）
   - 半结构化：中等精度（4-7）
   - 严格格式化（JSON、XML）：高精度（8-10）

2. **准确性需求**：事实准确性有多重要？
   - 创意内容：低精度（1-3）
   - 信息内容：中等精度（4-7）
   - 关键信息：高精度（8-10）

3. **可重现性**：结果在运行之间必须有多一致？
   - 变化可接受：低精度（1-3）
   - 需要一些一致性：中等精度（4-7）
   - 需要精确可重现性：高精度（8-10）

4. **错误容忍度**：错误的影响是什么？
   - 低影响：低精度（1-3）
   - 中等影响：中等精度（4-7）
   - 高影响：高精度（8-10）

计算你的平均分数以确定整体精度要求。

### 步骤 3：映射到矩阵

将你的复杂性和精度分数绘制在矩阵上：

- **低复杂性（1-4），低精度（1-4）**：简单 Crews
- **低复杂性（1-4），高精度（5-10）**：带直接 LLM 调用的 Flows
- **高复杂性（5-10），低精度（1-4）**：复杂 Crews
- **高复杂性（5-10），高精度（5-10）**：编排 Crews 的 Flows

### 步骤 4：考虑其他因素

除了复杂性和精度，还要考虑：

1. **开发时间**：Crews 通常更快原型化
2. **维护需求**：Flows 提供更好的长期可维护性
3. **团队专业知识**：考虑你的团队对不同方法的熟悉程度
4. **可扩展性需求**：Flows 通常对复杂应用程序扩展得更好
5. **集成需求**：考虑解决方案如何与现有系统集成

## 结论

在 Crews 和 Flows 之间选择——或结合它们——是一个关键的架构决策，影响你的 CrewAI 应用程序的有效性、可维护性和可扩展性。通过沿着复杂性和精度维度评估你的用例，你可以做出符合你特定需求的明智决策。

记住，最好的方法通常随着你的应用程序成熟而发展。从满足你需求的最简单解决方案开始，并在获得经验和需求变得更清晰时准备完善你的架构。

<Check>
你现在有了一个评估 CrewAI 用例并根据复杂性和精度要求选择正确方法的框架。这将帮助你构建更有效、可维护和可扩展的 AI 应用程序。
</Check>

## 下一步

- 了解更多关于[打造高效智能体](/zh/guides/agents/crafting-effective-agents)
- 探索[构建你的第一个 crew](/zh/guides/crews/first-crew)
- 深入[掌握 flow 状态管理](/zh/guides/flows/mastering-flow-state)
- 查看[核心概念](/zh/concepts/agents)以获得更深入的理解